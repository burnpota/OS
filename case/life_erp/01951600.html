======================<br><b>생성계정 : 우택 심</b><br><b>생성날짜 : 2017-10-13T00:37:52Z</b><br><b>마지막 답변자 : 우택 심</b><br><b>마지막 수정 일자 : 2017-10-23T07:50:24Z</b><br><b>id : 500A000000YTAOCIA5</b><br>======================<br><br><b><font size=15>
제목  : DBKSML02SL Call Trace 메세지 발생의 건 문의
</font></b><br><br>======================<br><b>사전문의<br></b><br>어떤 문제/오류/결함이 발생했습니까? 기대하시는 결과는 무엇입니까?<br><br>안녕하세요.<br><br>DR Backup 시스템에서 2017-10-12 20:34:58 경 아래와 같은 Call Trace 가 감지되었습니다.<br><br>어디서 문제가 발생했습니까? 어떤 환경에서 발생했습니까?<br><br>Oct 12 20:34:58 DBKSML02SL kernel: ------------[ cut here ]------------<br>Oct 12 20:34:58 DBKSML02SL kernel: WARNING: at net/ipv4/tcp_output.c:1121 tcp_fragment+0x2b8/0x2d0()<br>Oct 12 20:34:58 DBKSML02SL kernel: Modules linked in: nfsv3 rpcsec_gss_krb5 nfsv4 dns_resolver nfs fscache RedCastle(POE) bonding iptable_filter intel_powerclamp coretemp intel_rapl kvm iTCO_wdt crc32_pclmul iTCO_vendor_support ghash_clmulni_intel aesni_intel lrw gf128mul glue_helper ablk_helper pcspkr dm_service_time sb_edac hpwdt hpilo ipmi_ssif ses edac_core cryptd enclosure sg shpchp lpc_ich i2c_i801 ipmi_si wmi mfd_core ipmi_msghandler pcc_cpufreq acpi_power_meter dm_multipath dm_mod binfmt_misc nfsd auth_rpcgss nfs_acl lockd grace sunrpc ip_tables xfs libcrc32c sr_mod cdrom crc32c_intel serio_raw mgag200 syscopyarea sysfillrect sysimgblt i2c_algo_bit drm_kms_helper ahci ttm libahci drm libata tg3(OE) i2c_core ixgbe(OE) vxlan ip6_udp_tunnel udp_tunnel ptp pps_core dca sd_mod crc_t10dif crct10dif_generic crct10dif_pclmul<br>Oct 12 20:34:58 DBKSML02SL kernel: crct10dif_common qla2xxx(OE) scsi_transport_fc scsi_tgt hpsa(OE) scsi_transport_sas<br>Oct 12 20:34:58 DBKSML02SL kernel: CPU: 0 PID: 0 Comm: swapper/0 Tainted: P           OE  ------------   3.10.0-327.53.1.el7.x86_64 #1<br>Oct 12 20:34:58 DBKSML02SL kernel: Hardware name: HP ProLiant DL380 Gen9/ProLiant DL380 Gen9, BIOS P89 02/17/2017<br>Oct 12 20:34:58 DBKSML02SL kernel: 0000000000000000 96c854dd16c85994 ffff881fff2037d0 ffffffff81636b21<br>Oct 12 20:34:58 DBKSML02SL kernel: ffff881fff203808 ffffffff8107b260 ffff880232055000 ffff881f4a2f8000<br>Oct 12 20:34:58 DBKSML02SL kernel: ffff881fff203940 00000000000005a8 ffff881f4a2f8138 ffff881fff203818<br>Oct 12 20:34:58 DBKSML02SL kernel: Call Trace:<br>Oct 12 20:34:58 DBKSML02SL kernel: &lt;IRQ&gt;  [&lt;ffffffff81636b21&gt;] dump_stack+0x19/0x1b<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8107b260&gt;] warn_slowpath_common+0x70/0xb0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8107b3aa&gt;] warn_slowpath_null+0x1a/0x20<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81583638&gt;] tcp_fragment+0x2b8/0x2d0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81579120&gt;] tcp_match_skb_to_sack+0x70/0xd0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8157bbe2&gt;] tcp_sacktag_walk+0xf2/0x520<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8156cc2f&gt;] ? ip_output+0x6f/0xe0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8157c450&gt;] tcp_sacktag_write_queue+0x440/0xb50<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8156a8a1&gt;] ? ip_local_out_sk+0x31/0x40<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8157faae&gt;] tcp_ack+0x69e/0x12c0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffffa014cd07&gt;] ? ipt_do_table+0x337/0x710 [ip_tables]<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81580c95&gt;] tcp_rcv_established+0x1d5/0x750<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8163e9ed&gt;] ? common_interrupt+0x6d/0x6d<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8158b70a&gt;] tcp_v4_do_rcv+0x10a/0x340<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff812856c6&gt;] ? security_sock_rcv_skb+0x16/0x20<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8158cec2&gt;] tcp_v4_rcv+0x7a2/0x980<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffffa0545036&gt;] ? iptable_filter_hook+0x36/0x80 [iptable_filter]<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81566ab4&gt;] ip_local_deliver_finish+0xb4/0x1f0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81566d99&gt;] ip_local_deliver+0x59/0xd0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81566a00&gt;] ? ip_rcv_finish+0x350/0x350<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8156672d&gt;] ip_rcv_finish+0x7d/0x350<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff815670c6&gt;] ip_rcv+0x2b6/0x410<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8152b102&gt;] __netif_receive_skb_core+0x582/0x7f0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8101c859&gt;] ? read_tsc+0x9/0x10<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8152b388&gt;] __netif_receive_skb+0x18/0x60<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8152b410&gt;] netif_receive_skb+0x40/0xc0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8152bf80&gt;] napi_gro_receive+0x80/0xb0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffffa01715b5&gt;] ixgbe_clean_rx_irq+0x825/0xfc0 [ixgbe]<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffffa0172d58&gt;] ixgbe_poll+0x2d8/0x6d0 [ixgbe]<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8152b842&gt;] net_rx_action+0x152/0x240<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81084baf&gt;] __do_softirq+0xef/0x280<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81648b1c&gt;] call_softirq+0x1c/0x30<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81016fc5&gt;] do_softirq+0x65/0xa0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81084f45&gt;] irq_exit+0x115/0x120<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff816496b8&gt;] do_IRQ+0x58/0xf0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8163e9ed&gt;] common_interrupt+0x6d/0x6d<br>Oct 12 20:34:58 DBKSML02SL kernel: &lt;EOI&gt;  [&lt;ffffffff81058e96&gt;] ? native_safe_halt+0x6/0x10<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8101dbff&gt;] default_idle+0x1f/0xc0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8101e506&gt;] arch_cpu_idle+0x26/0x30<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff810d6605&gt;] cpu_startup_entry+0x245/0x290<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81626787&gt;] rest_init+0x77/0x80<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81a90057&gt;] start_kernel+0x429/0x44a<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81a8fa37&gt;] ? repair_env_string+0x5c/0x5c<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81a8f120&gt;] ? early_idt_handlers+0x120/0x120<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81a8f5ee&gt;] x86_64_start_reservations+0x2a/0x2c<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81a8f742&gt;] x86_64_start_kernel+0x152/0x175<br>Oct 12 20:34:58 DBKSML02SL kernel: ---[ end trace c03d5d25b12b11df ]---<br><br>언제 문제가 발생했습니까? 이러한 문제가 자주 발생합니까? 반복적으로 발생합니까? 특정 시간에 발생합니까?<br><br>메세지 로그만 기록되고 시스템에 특별한 영향도는 없는것으로 판단되는데요,<br><br>위와 같은 Call Trace 가 의미하는 내용 확인 부탁드립니다.<br><br>해결 기간이나 업무에 미치는 영향에 대한 정보를 제공해 주시겠습니까?<br><br>DBKSML02SL 시스템의 sosreport 와 로그를 dropbox.redhat.com/incoming 에 아래와 같은 파일명으로 업로드 하도록 하겠습니다.<br><br>sosreport-DBKSML02SL-20171013090951.tar.xz<br>sosreport-DBKSML02SL-LOG-20171013090951.tar.gz<br><br>감사합니다.<br>=======================<br><b>상태 : Closed</b><br><b>제품명  : Red Hat Enterprise Linux</b><br><b>버젼  : 7.2</b><br><b>타입  : Defect / Bug</b><br><b>계정 번호  : 5251314</b><br><b>심각도  : 4 (Low)</b><br><hostname>DBKSML02SL</hostname><br><br><br><comment id="a0aA000000KgqbSIAR"><br>======================<br><b>생성계정 : Huang, Ying</b><br><b>생성날짜 : 2017-10-13T06:32:31Z</b><br><b>마지막 답변자 : Huang, Ying</b><br><b>마지막 수정 일자 : 2017-10-13T06:32:31Z</b><br><br>안녕하세요,<br><br>Red Hat Global Support Services를 이용해주셔서 감사합니다.<br><br>앞서 안내해드린 영문 부분에서 보시면 skb으로 패스된 값이 length으로 패스된 것보다 작아 tcp_fragment() 함수의 <br>첫번째 WARN_ON()을 트리거하여 발생된 이슈인것으로 보고되어 있습니다.<br>It is being triggered by the first WARN_ON() in the tcp_fragment() function because the passed in skb is less than the passed in length (so then there would be no apparent reason to fragment). In your case, tcp_fragment() is always being called by tcp_mark_head_lost().<br><br>감사합니다.<br><br><publishedDate>2017-10-13T06:32:31Z</publishedDate><createdByType>Associate</createdByType><br>======================<br><comment id="a0aA000000KgplCIAR"><br>======================<br><b>생성계정 : 심, 우택</b><br><b>생성날짜 : 2017-10-13T05:01:58Z</b><br><b>마지막 답변자 : 심, 우택</b><br><b>마지막 수정 일자 : 2017-10-13T05:01:58Z</b><br><br>안녕하세요. 빠른 답변 감사합니다.<br><br>그렇다면 문의드린 Call Trace 가 어떤 상황에서 발생되는지 조건을 알 수 있을 까요?<br><br>해당 시스템의 Log 및 Sar 데이터를 봐도 특이 사항이 없던 시간대에 발생해서,<br><br>메세지 발생 조건을 알려주신다면 모니터링에 참고 하도록 하겠습니다.<br><br>감사합니다.<br><br><publishedDate>2017-10-13T05:01:58Z</publishedDate><createdByType>Customer</createdByType><br>======================<br><comment id="a0aA000000KgonJIAR"><br>======================<br><b>생성계정 : Huang, Ying</b><br><b>생성날짜 : 2017-10-13T02:21:28Z</b><br><b>마지막 답변자 : Huang, Ying</b><br><b>마지막 수정 일자 : 2017-10-13T02:21:28Z</b><br><br>안녕하세요,<br><br>Red Hat Global Support Services를 이용해주셔서 감사합니다.<br><br>말씀하신 로그는 warning 메시지이며 시스템 네트워크 컨낵션에는 문제가 없는것으로 보입니다.<br>혹시 이슈가 있으시다면 알려 주시기 바랍니다.<br>또한 해당 이슈에 대하여 메시지가 출력되지 않게 최신버전에서 패치를 적용되었습니다.<br>메시지 출력을 방지 하시려면 kernel 최신버전으로 업그레이드 해주시기 바랍니다.<br><br>It is being triggered by the first WARN_ON() in the tcp_fragment() function because the passed in skb is less than the passed in length (so then there would be no apparent reason to fragment). In your case, tcp_fragment() is always being called by tcp_mark_head_lost().<br><br>1107 /* Function to create two new TCP segments.  Shrinks the given segment<br>1108  * to the specified size and appends a new segment with the rest of the<br>1109  * packet to the list.  This won't be called frequently, I hope.<br>1110  * Remember, these are still headerless SKBs at this point.<br>1111  */<br>1112 int tcp_fragment(struct sock *sk, struct sk_buff *skb, u32 len,<br>1113                  unsigned int mss_now)<br>1114 {<br>1115         struct tcp_sock *tp = tcp_sk(sk);<br>1116         struct sk_buff *buff;<br>1117         int nsize, old_factor;<br>1118         int nlen;<br>1119         u8 flags;<br>1120 <br>1121         if (WARN_ON(len &gt; skb-&gt;len))<br>1122                 return -EINVAL;<br>1123 <br>======================<br>There is an upstream commit which appears to address an issue where tcp_mark_head_lost() will now check the skb length before passing it to tcp_fragment(). I suspect this patch would avoid the WARN_ON() in your case and this patch has committed to new RHEL kernel version.<br><br>commit d88270eef4b56bd7973841dd1fed387ccfa83709<br>Author: Neal Cardwell &lt;ncardwell@google.com&gt;<br>Date:   Mon Jan 25 14:01:53 2016 -0800<br><br>    tcp: fix tcp_mark_head_lost to check skb len before fragmenting<br>    <br>    This commit fixes a corner case in tcp_mark_head_lost() which was<br>    causing the WARN_ON(len &gt; skb-&gt;len) in tcp_fragment() to fire.<br>    <br>    tcp_mark_head_lost() was assuming that if a packet has<br>    tcp_skb_pcount(skb) of N, then it's safe to fragment off a prefix of<br>    M*mss bytes, for any M &lt; N. But with the tricky way TCP pcounts are<br>    maintained, this is not always true.<br>    <br>    For example, suppose the sender sends 4 1-byte packets and have the<br>    last 3 packet sacked. It will merge the last 3 packets in the write<br>    queue into an skb with pcount = 3 and len = 3 bytes. If another<br>    recovery happens after a sack reneging event, tcp_mark_head_lost()<br>    may attempt to split the skb assuming it has more than 2*MSS bytes.<br>    <br>    This sounds very counterintuitive, but as the commit description for<br>    the related commit c0638c247f55 (&quot;tcp: don't fragment SACKed skbs in<br>    tcp_mark_head_lost()&quot;) notes, this is because tcp_shifted_skb()<br>    coalesces adjacent regions of SACKed skbs, and when doing this it<br>    preserves the sum of their packet counts in order to reflect the<br>    real-world dynamics on the wire. The c0638c247f55 commit tried to<br>    avoid problems by not fragmenting SACKed skbs, since SACKed skbs are<br>    where the non-proportionality between pcount and skb-&gt;len/mss is known<br>    to be possible. However, that commit did not handle the case where<br>    during a reneging event one of these weird SACKed skbs becomes an<br>    un-SACKed skb, which tcp_mark_head_lost() can then try to fragment.<br>    <br>    The fix is to simply mark the entire skb lost when this happens.<br>    This makes the recovery slightly more aggressive in such corner<br>    cases before we detect reordering. But once we detect reordering<br>    this code path is by-passed because FACK is disabled.<br>    <br>    Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;<br>    Signed-off-by: Yuchung Cheng &lt;ycheng@google.com&gt;<br>    Signed-off-by: Eric Dumazet &lt;edumazet@google.com&gt;<br>    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;<br><br>diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c<br>index 0003d40..d2ad433 100644<br>--- a/net/ipv4/tcp_input.c<br>+++ b/net/ipv4/tcp_input.c<br>@@ -2164,8 +2164,7 @@ static void tcp_mark_head_lost(struct sock *sk, int packets, int mark_head)<br> {<br>        struct tcp_sock *tp = tcp_sk(sk);<br>        struct sk_buff *skb;<br>-       int cnt, oldcnt;<br>-       int err;<br>+       int cnt, oldcnt, lost;<br>        unsigned int mss;<br>        /* Use SACK to deduce losses of new sequences sent during recovery */<br>        const u32 loss_high = tcp_is_sack(tp) ?  tp-&gt;snd_nxt : tp-&gt;high_seq;<br>@@ -2205,9 +2204,10 @@ static void tcp_mark_head_lost(struct sock *sk, int packets, int mark_head)<br>                                break;<br> <br>                        mss = tcp_skb_mss(skb);<br>-                       err = tcp_fragment(sk, skb, (packets - oldcnt) * mss,<br>-                                          mss, GFP_ATOMIC);<br>-                       if (err &lt; 0)<br>+                       /* If needed, chop off the prefix to mark as lost. */<br>+                       lost = (packets - oldcnt) * mss;<br>+                       if (lost &lt; skb-&gt;len &amp;&amp;<br>+                           tcp_fragment(sk, skb, lost, mss, GFP_ATOMIC) &lt; 0)<br>                                break;<br>                        cnt = packets;<br>                }<br><br>감사합니다.<br><br><publishedDate>2017-10-13T02:21:28Z</publishedDate><createdByType>Associate</createdByType><br>======================<br></comments><br><br>DR Backup 시스템에서 2017-10-12 20:34:58 경 아래와 같은 Call Trace 가 감지되었습니다.</issue><environment>Oct 12 20:34:58 DBKSML02SL kernel: ------------[ cut here ]------------<br>Oct 12 20:34:58 DBKSML02SL kernel: WARNING: at net/ipv4/tcp_output.c:1121 tcp_fragment+0x2b8/0x2d0()<br>Oct 12 20:34:58 DBKSML02SL kernel: Modules linked in: nfsv3 rpcsec_gss_krb5 nfsv4 dns_resolver nfs fscache RedCastle(POE) bonding iptable_filter intel_powerclamp coretemp intel_rapl kvm iTCO_wdt crc32_pclmul iTCO_vendor_support ghash_clmulni_intel aesni_intel lrw gf128mul glue_helper ablk_helper pcspkr dm_service_time sb_edac hpwdt hpilo ipmi_ssif ses edac_core cryptd enclosure sg shpchp lpc_ich i2c_i801 ipmi_si wmi mfd_core ipmi_msghandler pcc_cpufreq acpi_power_meter dm_multipath dm_mod binfmt_misc nfsd auth_rpcgss nfs_acl lockd grace sunrpc ip_tables xfs libcrc32c sr_mod cdrom crc32c_intel serio_raw mgag200 syscopyarea sysfillrect sysimgblt i2c_algo_bit drm_kms_helper ahci ttm libahci drm libata tg3(OE) i2c_core ixgbe(OE) vxlan ip6_udp_tunnel udp_tunnel ptp pps_core dca sd_mod crc_t10dif crct10dif_generic crct10dif_pclmul<br>Oct 12 20:34:58 DBKSML02SL kernel: crct10dif_common qla2xxx(OE) scsi_transport_fc scsi_tgt hpsa(OE) scsi_transport_sas<br>Oct 12 20:34:58 DBKSML02SL kernel: CPU: 0 PID: 0 Comm: swapper/0 Tainted: P           OE  ------------   3.10.0-327.53.1.el7.x86_64 #1<br>Oct 12 20:34:58 DBKSML02SL kernel: Hardware name: HP ProLiant DL380 Gen9/ProLiant DL380 Gen9, BIOS P89 02/17/2017<br>Oct 12 20:34:58 DBKSML02SL kernel: 0000000000000000 96c854dd16c85994 ffff881fff2037d0 ffffffff81636b21<br>Oct 12 20:34:58 DBKSML02SL kernel: ffff881fff203808 ffffffff8107b260 ffff880232055000 ffff881f4a2f8000<br>Oct 12 20:34:58 DBKSML02SL kernel: ffff881fff203940 00000000000005a8 ffff881f4a2f8138 ffff881fff203818<br>Oct 12 20:34:58 DBKSML02SL kernel: Call Trace:<br>Oct 12 20:34:58 DBKSML02SL kernel: &lt;IRQ&gt;  [&lt;ffffffff81636b21&gt;] dump_stack+0x19/0x1b<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8107b260&gt;] warn_slowpath_common+0x70/0xb0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8107b3aa&gt;] warn_slowpath_null+0x1a/0x20<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81583638&gt;] tcp_fragment+0x2b8/0x2d0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81579120&gt;] tcp_match_skb_to_sack+0x70/0xd0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8157bbe2&gt;] tcp_sacktag_walk+0xf2/0x520<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8156cc2f&gt;] ? ip_output+0x6f/0xe0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8157c450&gt;] tcp_sacktag_write_queue+0x440/0xb50<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8156a8a1&gt;] ? ip_local_out_sk+0x31/0x40<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8157faae&gt;] tcp_ack+0x69e/0x12c0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffffa014cd07&gt;] ? ipt_do_table+0x337/0x710 [ip_tables]<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81580c95&gt;] tcp_rcv_established+0x1d5/0x750<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8163e9ed&gt;] ? common_interrupt+0x6d/0x6d<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8158b70a&gt;] tcp_v4_do_rcv+0x10a/0x340<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff812856c6&gt;] ? security_sock_rcv_skb+0x16/0x20<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8158cec2&gt;] tcp_v4_rcv+0x7a2/0x980<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffffa0545036&gt;] ? iptable_filter_hook+0x36/0x80 [iptable_filter]<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81566ab4&gt;] ip_local_deliver_finish+0xb4/0x1f0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81566d99&gt;] ip_local_deliver+0x59/0xd0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81566a00&gt;] ? ip_rcv_finish+0x350/0x350<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8156672d&gt;] ip_rcv_finish+0x7d/0x350<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff815670c6&gt;] ip_rcv+0x2b6/0x410<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8152b102&gt;] __netif_receive_skb_core+0x582/0x7f0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8101c859&gt;] ? read_tsc+0x9/0x10<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8152b388&gt;] __netif_receive_skb+0x18/0x60<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8152b410&gt;] netif_receive_skb+0x40/0xc0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8152bf80&gt;] napi_gro_receive+0x80/0xb0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffffa01715b5&gt;] ixgbe_clean_rx_irq+0x825/0xfc0 [ixgbe]<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffffa0172d58&gt;] ixgbe_poll+0x2d8/0x6d0 [ixgbe]<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8152b842&gt;] net_rx_action+0x152/0x240<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81084baf&gt;] __do_softirq+0xef/0x280<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81648b1c&gt;] call_softirq+0x1c/0x30<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81016fc5&gt;] do_softirq+0x65/0xa0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81084f45&gt;] irq_exit+0x115/0x120<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff816496b8&gt;] do_IRQ+0x58/0xf0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8163e9ed&gt;] common_interrupt+0x6d/0x6d<br>Oct 12 20:34:58 DBKSML02SL kernel: &lt;EOI&gt;  [&lt;ffffffff81058e96&gt;] ? native_safe_halt+0x6/0x10<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8101dbff&gt;] default_idle+0x1f/0xc0<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff8101e506&gt;] arch_cpu_idle+0x26/0x30<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff810d6605&gt;] cpu_startup_entry+0x245/0x290<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81626787&gt;] rest_init+0x77/0x80<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81a90057&gt;] start_kernel+0x429/0x44a<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81a8fa37&gt;] ? repair_env_string+0x5c/0x5c<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81a8f120&gt;] ? early_idt_handlers+0x120/0x120<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81a8f5ee&gt;] x86_64_start_reservations+0x2a/0x2c<br>Oct 12 20:34:58 DBKSML02SL kernel: [&lt;ffffffff81a8f742&gt;] x86_64_start_kernel+0x152/0x175<br>Oct 12 20:34:58 DBKSML02SL kernel: ---[ end trace c03d5d25b12b11df ]---</environment><periodicityOfIssue>메세지 로그만 기록되고 시스템에 특별한 영향도는 없는것으로 판단되는데요,<br><br>위와 같은 Call Trace 가 의미하는 내용 확인 부탁드립니다.</periodicityOfIssue><timeFramesAndUrgency>DBKSML02SL 시스템의 sosreport 와 로그를 dropbox.redhat.com/incoming 에 아래와 같은 파일명으로 업로드 하도록 하겠습니다.<br><br>sosreport-DBKSML02SL-20171013090951.tar.xz<br>sosreport-DBKSML02SL-LOG-20171013090951.tar.gz<br><br>감사합니다.</timeFramesAndUrgency><cep>false</cep></case>