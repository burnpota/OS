======================<br><b>생성계정 : jimin kim</b><br><b>생성날짜 : 2016-04-18T12:08:59Z</b><br><b>마지막 답변자 : 우택 심</b><br><b>마지막 수정 일자 : 2016-05-23T06:05:26Z</b><br><b>id : 500A000000U2jgkIAB</b><br>======================<br><br><b><font size=15>
제목  : RHEL7 / RHEL6
</font></b><br><br>======================<br><b>사전문의<br></b><br>어떤 문제/오류/결함이 발생했습니까? 기대하시는 결과는 무엇입니까?<br><br>안녕하세요 <br><br>보험ERP 프로젝트 진행 중인 SDS 김지민 선임입니다.<br><br>현재 보험ERP 서버들은 RHEL7 버전과 RHEL6 버전으로 구성되어 있습니다.<br><br>6과 7버전에 따라서 동일한 파라미터도 있지만 각각의 버전이 가지고 있는 고유의 파라미터도 있습니다.<br><br>문의드릴점은 아래 첨부로 각 버전 고유의 파라미터를 첨부하였는데요.<br><br>해당 파라미터 중에서 운영에 있어서 확인해볼만한 파라미터가 있는지 확인을 부탁드리려고 합니다.<br><br>좀 광범위한 문의 같기도 합니다.<br><br>ipv6 등은 기본으로 disable 상태이긴해서 고려할 필요는 없을 듯하고<br>또 xfs에 관한 파라미터에 대해서는 xfs를 사용하고있어서 확인하고 있어야할 점이 있는지 해서 <br>일단 문의드립니다.<br><br>문제 해결 기간 및  긴급도와 관련된 정보를 제공해 주시겠습니까?<br><br>[ *** RHEL7 에 추가 된 파라미터 목록 *** ]<br>dev.parport.default.spintime <br>dev.parport.default.timeslice <br>fs.binfmt_misc.kshcomp <br>fs.pipe-max-size <br>fs.protected_hardlinks <br>fs.protected_symlinks <br>fs.xfs.age_buffer_centisecs <br>fs.xfs.error_level <br>fs.xfs.filestream_centisecs <br>fs.xfs.inherit_noatime <br>fs.xfs.inherit_nodefrag <br>fs.xfs.inherit_nodump <br>fs.xfs.inherit_nosymlinks <br>fs.xfs.inherit_sync <br>fs.xfs.irix_sgid_inherit <br>fs.xfs.irix_symlink_mode <br>fs.xfs.panic_mask <br>fs.xfs.rotorstep <br>fs.xfs.speculative_prealloc_lifetime <br>fs.xfs.stats_clear <br>fs.xfs.xfsbufd_centisecs <br>fs.xfs.xfssyncd_centisecs <br>fscache.object_max_active <br>fscache.operation_max_active <br>kernel.keys.persistent_keyring_expiry <br>kernel.msg_next_id <br>kernel.ns_last_pid <br>kernel.numa_balancing <br>kernel.numa_balancing_scan_delay_ms <br>kernel.numa_balancing_scan_period_max_ms <br>kernel.numa_balancing_scan_period_min_ms <br>kernel.numa_balancing_scan_size_mb <br>kernel.numa_balancing_settle_count <br>kernel.panic_on_stackoverflow <br>kernel.perf_cpu_time_max_percent <br>kernel.pty.reserve <br>kernel.sem_next_id <br>kernel.shm_next_id <br>kernel.traceoff_on_warning <br>net.core.bpf_jit_enable <br>net.core.default_qdisc <br>net.core.netdev_tstamp_prequeue <br>net.ipv4.igmp_qrv <br>net.ipv4.ip_early_demux <br>net.ipv4.neigh.default.unres_qlen_bytes <br>net.ipv4.neigh.lo.unres_qlen_bytes <br>net.ipv4.tcp_autocorking <br>net.ipv4.tcp_early_retrans <br>net.ipv4.tcp_fastopen <br>net.ipv4.tcp_fastopen_key <br>net.ipv4.tcp_invalid_ratelimit <br>net.ipv4.tcp_notsent_lowat <br>net.ipv6.conf.all.force_tllao <br>net.ipv6.conf.all.mldv1_unsolicited_report_interval <br>net.ipv6.conf.all.mldv2_unsolicited_report_interval <br>net.ipv6.conf.all.ndisc_notify <br>net.ipv6.conf.default.force_tllao <br>net.ipv6.conf.default.mldv1_unsolicited_report_interval <br>net.ipv6.conf.default.mldv2_unsolicited_report_interval <br>net.ipv6.conf.default.ndisc_notify <br>net.ipv6.conf.lo.force_tllao <br>net.ipv6.conf.lo.mldv1_unsolicited_report_interval <br>net.ipv6.conf.lo.mldv2_unsolicited_report_interval <br>net.ipv6.conf.lo.ndisc_notify <br>net.ipv6.mld_qrv <br>net.ipv6.neigh.default.unres_qlen_bytes <br>net.ipv6.neigh.lo.unres_qlen_bytes <br>vm.user_reserve_kbytes <br>net.bridge.bridge-nf-pass-vlan-input-dev<br>======================<br><br>[ *** RHEL6 에는 있지만, RHEL7 에는 없는 파라미터 *** ]<br><br>fs.nfs.idmap_cache_timeout <br>fs.nfs.nfs_callback_tcpport <br>kernel.exec-shield <br>kernel.slow-work.max-threads <br>kernel.slow-work.min-threads <br>kernel.slow-work.vslow-percentage <br>kernel.vsyscall64 <br>net.ipv4.inet_peer_gc_maxtime <br>net.ipv4.inet_peer_gc_mintime <br>net.ipv4.neigh.default.base_reachable_time <br>net.ipv4.neigh.default.retrans_time <br>net.ipv4.neigh.lo.base_reachable_time <br>net.ipv4.neigh.lo.retrans_time <br>net.ipv4.route.secret_interval <br>net.ipv4.rt_cache_rebuild_count <br>net.ipv4.tcp_abc <br>net.ipv4.tcp_dma_copybreak <br>net.ipv4.tcp_frto_response <br>net.sctp.addip_enable <br>net.sctp.addip_noauth_enable <br>net.sctp.addr_scope_policy <br>net.sctp.association_max_retrans <br>net.sctp.auth_enable <br>net.sctp.cookie_hmac_alg <br>net.sctp.cookie_preserve_enable <br>net.sctp.hb_interval <br>net.sctp.max_burst <br>net.sctp.max_init_retransmits <br>net.sctp.path_max_retrans <br>net.sctp.pf_retrans <br>net.sctp.prsctp_enable <br>net.sctp.rcvbuf_policy <br>net.sctp.rto_alpha_exp_divisor <br>net.sctp.rto_beta_exp_divisor <br>net.sctp.rto_initial <br>net.sctp.rto_max <br>net.sctp.rto_min <br>net.sctp.rwnd_update_shift <br>net.sctp.sack_timeout <br>net.sctp.sctp_mem <br>net.sctp.sctp_rmem <br>net.sctp.sctp_wmem <br>net.sctp.sndbuf_policy <br>net.sctp.valid_cookie_life <br>vm.extra_free_kbytes <br>vm.meminfo_legacy_layout <br>vm.scan_unevictable_pages <br>vm.unmap_area_factor <br>vm.would_have_oomkilled<br>=======================<br><b>상태 : Closed</b><br><b>제품명  : Red Hat Enterprise Linux</b><br><b>버젼  : 7.1</b><br><b>계정 번호  : 5251314</b><br><b>심각도  : 4 (Low)</b><br>======================<br><comment id="a0aA000000GErsBIAT"><br>======================<br><b>생성계정 : HAN, JINKOO</b><br><b>생성날짜 : 2016-05-13T04:24:19Z</b><br><b>마지막 답변자 : HAN, JINKOO</b><br><b>마지막 수정 일자 : 2016-05-13T04:24:19Z</b><br><br>안녕하세요,<br>Red Hat 한진구 입니다.<br><br>보내주신 자료들에 대해서 간단하게 무엇을 하는지에 대해서만 한글로 간략히 기재해서 드립니다.<br><br>참고로, 기능에 대한 오해의 소지 등등의 이유로 원문 그자체로 전달드렸으며, 원문을 기반으로 참고하시기를 바랍니다.<br><br><br>@ vm<br><br>- vm.user_reserve_kbytes <br><br>overcommit_memory 설정이 '2'(&quot;nerver overcommit&quot;) 모드일때, 여유 메모리에서 최소 reserve 할 수 있는 사이즈를 설정<br>만약 해당 값이 '0'으로 설정하게 될 경우, 모든 여유 메모리 공간을 할당하여 사용할 수 있도록 허락되어 집니다.<br>======================<br>@ fs<br><br>- fs.xfs.age_buffer_centisecs <br><br>xfsbufd가 dirty metadata buffer를 디스크로 flush하는 age 값 설정<br><br><br>- fs.xfs.error_level <br><br>볼륨의 내무적인 에러가 발생할때 에러를 reporting 설정이며, 이 설정은 파일시스템 shutdown을 위한 자세한 message와 backtraces 들을 발생하게 됨.<br><br><br>- fs.xfs.inherit_noatime <br><br>'1'로 설정할 경우, xfs_io chattr 명령어로 설정한 &quot;noatime&quot; flag가 디렉토리안의 파일들에 상속됨.<br><br><br>- fs.xfs.inherit_nodefrag <br><br>'1'로 설정할 경우, xfs_io chattr 명령어로 설정한 &quot;nodefrag&quot; flag가 디렉토리안의 파일들에 상속됨.<br><br><br>- fs.xfs.inherit_nodump <br><br>'1'로 설정할 경우, xfs_io chattr 명령어로 설정한 &quot;nodump&quot; flag가 디렉토리안의 파일들에 상속됨.<br><br><br>- fs.xfs.inherit_nosymlinks <br><br>'1'로 설정할 경우, xfs_io chattr 명령어로 설정한 &quot;nosymlinks&quot; flag가 디렉토리안의 파일들에 상속됨.<br><br><br>- fs.xfs.inherit_sync <br><br>'1'로 설정할 경우, xfs_io chattr 명령어로 설정한 &quot;sync&quot; flag가 디렉토리안의 파일들에 상속됨.<br>        <br><br>- fs.xfs.irix_symlink_mode<br><br>symlinks가 mode 0777로 생성되었는지 그 모드가 umask (irix mode)에 의해서 영향을 받은 것인지를 control함.<br><br><br>- fs.xfs.panic_mask <br><br>BUG() 함수를 호출하기 위한 error condition을 설정이며 값은 bitmask로 설정할 수 있으고, 또한 패닉의 원인이 될 수 있는 error들을 함께 사용할 수 있음<br><br>                XFS_NO_PTAG                     0<br>                XFS_PTAG_IFLUSH                 0x00000001<br>                XFS_PTAG_LOGRES                 0x00000002<br>                XFS_PTAG_AILDELETE              0x00000004<br>                XFS_PTAG_ERROR_REPORT           0x00000008<br>                XFS_PTAG_SHUTDOWN_CORRUPT       0x00000010<br>                XFS_PTAG_SHUTDOWN_IOERROR       0x00000020<br>                XFS_PTAG_SHUTDOWN_LOGERROR      0x00000040<br><br>해당 옵션은 only 디버깅을위한 목적임.<br><br><br>- fs.xfs.rotorstep <br><br>&quot;inode32&quot; allocation mode에서, 이 옵션은 allocator가 얼마나 많은 파일들을 다음 allocation group에 이동하기 전에 같은 allocation group에 할당을 시도할 지를 설정.<br><br><br>- fs.xfs.speculative_prealloc_lifetime <br><br>inodes를 background 스캐닝을 위한 interval 설정이며, 해당 scan은 clean inodes로 부터 사전에 할당되어 사용되지 않는 것들을 제거하고 사용되지 않는 공간을 여유 pool로 반환함.<br><br><br>- fs.xfs.stats_clear <br><br>'1'로 설정하게 될 경우, /proc/fs/xfs/stat안에 누적된 XFS 통계를 삭제<br><br><br>- fs.xfs.xfsbufd_centisecs <br><br>xfsbufd가 dirty metadata buffer list를 스캔하는 interval<br><br><br>- fs.xfs.xfssyncd_centisecs <br><br>xfssyncd 쓰레드가 metadata를 디스크로 flush하기 위한 interval.<br>======================<br>@ kernel<br><br>- kernel.numa_balancing <br><br>NUMA 메모리 발란싱을 기반으로 자동으로 page fault를 Enable/Disable 설정. <br><br>The unmapping of pages and trapping faults incur additional overhead that ideally is offset by improved memory locality but there is no universal guarantee. If the target workload is already bound to NUMA nodes then this feature should be disabled. Otherwise, if the system overhead from the feature is too high then the rate the kernel samples for NUMA hinting faults may be controlled by the numa_balancing_scan_period_min_ms, numa_balancing_scan_delay_ms, numa_balancing_scan_period_max_ms, numa_balancing_scan_size_mb, and numa_balancing_settle_count sysctls.<br>======================<br>@ net<br><br>- net.core.bpf_jit_enable <br><br>해당 설정은 Berkely Packet Filter Just in Time 컴파일러를 활성을 설정.<br><br><br>- net.core.default_qdisc <br><br>네트워크 디바이스를 사용하기 위한 기본 queuing 규정. 기본값은 pfifo_fast<br><br><br>- net.core.netdev_tstamp_prequeue <br><br>기본값은 '1'이며, queuing하기 전에 가능한 빨리 timestamps가 sampled되어짐. <br><br><br>- net.ipv4.tcp_autocorking <br><br>응용프로그램이 연속적으로 small write()/sendmsg() 시스템콜을 수행할때, 가능한 많은 small writes 들을 합체하는 것을 시도하여 보내는 패킷의 전체 양을 줄이는 기능 활성화 설정 (기본으로 '1' 설정)<br><br><br>- net.ipv4.tcp_early_retrans <br><br>RFC 5827에 정의된 Early Retransmit(ER) 기능을 활성화 설정 및 Tail loss probe(TLP) 사용을 설정 (기본값: '3')<br><br>        Possible values:<br>                0 disables ER<br>                1 enables ER<br>                2 enables ER but delays fast recovery and fast retransmit<br>                  by a fourth of RTT. This mitigates connection falsely<br>                  recovers when network has a small degree of reordering<br>                  (less than 3 packets).<br>                3 enables delayed ER and TLP.<br>                4 enables TLP only.<br>======================<br>- net.ipv4.tcp_fastopen <br><br>opening SYN 패킷에서 데이터를 보내기 위해 TCP Fast Open 기능을 활성화 설정 (기본값은 '0')<br><br><br>- net.ipv4.tcp_invalid_ratelimit <br><br>incoming TCP 패킷에 응답시에 중복 acknowledgment를 보내는 최대 rate을 제한시간 설정으로 기본 500 milliseconds)이며, 아래와 같은 이유에서는 유효하지 않음<br><br>          (a) out-of-window sequence number,<br>          (b) out-of-window acknowledgment number, or<br>          (c) PAWS (Protection Against Wrapped Sequence numbers) check failure<br><br><br>- net.ipv4.tcp_notsent_lowat<br><br>TCP 소켓들은 write queue 에서 보내지않은 bytes의 양을 조절 <br>Default: UINT_MAX (0xFFFFFFFF)<br>======================<br>해당 값들에 대한 기본적인 권장사항은 Red Hat CEE입장에서는 권장값을 사용하사는 것을 권장하는 바입니다.<br>======================<br><br>업무에 참고하시기 바랍니다.<br><br>감사합니다.<br><br><publishedDate>2016-05-13T04:24:19Z</publishedDate><createdByType>Associate</createdByType><br>======================<br><comment id="a0aA000000H4KagIAF"><br>======================<br><b>생성계정 : HAN, JINKOO</b><br><b>생성날짜 : 2016-05-04T05:12:48Z</b><br><b>마지막 답변자 : HAN, JINKOO</b><br><b>마지막 수정 일자 : 2016-05-04T08:26:01Z</b><br><br>안녕하세요,<br>Red Hat 한진구 입니다.<br><br>제가 확인되는 자료의 위치 및 내용을 아래와 같이 공유 드립니다.<br><br><br>1. kernel parameter와 관련된 자료 확인은 아래 패키지를 설치후, 확인이 가능하십니다.<br><br># yum install kernel-doc<br># cd /usr/share/kernel-doc-&lt;ver&gt;/Documentation/<br>======================<br>2. 문의하신 파라미터들에 대한 내용입니다. <br><br>@ vm<br><br>- vm.user_reserve_kbytes <br><br>When overcommit_memory is set to 2, &quot;never overommit&quot; mode, reserve min(3% of current process size, user_reserve_kbytes) of free memory.<br>This is intended to prevent a user from starting a single memory hogging process, such that they cannot recover (kill the hog).<br><br>user_reserve_kbytes defaults to min(3% of the current process size, 128MB).<br><br>If this is reduced to zero, then the user will be allowed to allocate all free memory with a single process, minus admin_reserve_kbytes.<br>Any subsequent attempts to execute a command will result in &quot;fork: Cannot allocate memory&quot;.<br><br>Changing this takes effect whenever an application requests memory.<br>======================<br>@ fs<br><br>- fs.xfs.age_buffer_centisecs <br><br>The age at which xfsbufd flushes dirty metadata buffers to disk.<br><br><br>- fs.xfs.error_level <br><br>A volume knob for error reporting when internal errors occur. This will generate detailed messages &amp; backtraces for filesystem shutdowns<br><br><br>- fs.xfs.filestream_centisecs <br><br>The age at which xfsbufd flushes dirty metadata buffers to disk.<br><br><br>- fs.xfs.inherit_noatime <br><br>Setting this to &quot;1&quot; will cause the &quot;noatime&quot; flag set by the xfs_io(8) chattr command on a directory to be inherited by files in that directory.<br><br><br>- fs.xfs.inherit_nodefrag <br><br>Setting this to &quot;1&quot; will cause the &quot;nodefrag&quot; flag set by the xfs_io(8) chattr command on a directory to be inherited by files in that directory.<br><br><br>- fs.xfs.inherit_nodump <br><br>Setting this to &quot;1&quot; will cause the &quot;nodump&quot; flag set by the xfs_io(8) chattr command on a directory to be inherited by files in that directory.<br><br><br>- fs.xfs.inherit_nosymlinks <br><br>Setting this to &quot;1&quot; will cause the &quot;nosymlinks&quot; flag set by the xfs_io(8) chattr command on a directory to be inherited by files in that directory.<br><br><br>- fs.xfs.inherit_sync <br><br>Setting this to &quot;1&quot; will cause the &quot;sync&quot; flag set by the xfs_io(8) chattr command on a directory to be inherited by files in that directory.<br>        <br><br>- fs.xfs.irix_sgid_inherit <br><br>Controls files created in SGID directories. If the group ID of the new file does not match the effective group ID or one of the supplementary group IDs of the parent dir, the ISGID bit is cleared if the irix_sgid_inherit compatibility sysctl is set.<br>(Default: 0)<br><br><br>- fs.xfs.irix_symlink_mode<br><br>Controls whether symlinks are created with mode 0777 (default) or whether their mode is affected by the umask (irix mode).<br>(Default: 0)<br><br><br>- fs.xfs.panic_mask <br><br>Causes certain error conditions to call BUG(). Value is a bitmask; AND together the tags which represent errors which should cause panics:<br><br>                XFS_NO_PTAG                     0<br>                XFS_PTAG_IFLUSH                 0x00000001<br>                XFS_PTAG_LOGRES                 0x00000002<br>                XFS_PTAG_AILDELETE              0x00000004<br>                XFS_PTAG_ERROR_REPORT           0x00000008<br>                XFS_PTAG_SHUTDOWN_CORRUPT       0x00000010<br>                XFS_PTAG_SHUTDOWN_IOERROR       0x00000020<br>                XFS_PTAG_SHUTDOWN_LOGERROR      0x00000040<br><br>This option is intended for debugging only.<br>(Default: 0)<br><br><br>- fs.xfs.rotorstep <br><br>In &quot;inode32&quot; allocation mode, this option determines how many files the allocator attempts to allocate in the same allocation group before moving to the next allocation group.  <br>The intent is to control the rate at which the allocator moves between allocation groups when allocating extents for new files.<br>(Default: 1)<br><br><br>- fs.xfs.speculative_prealloc_lifetime <br><br>The interval at which the background scanning for inodes with unused speculative preallocation runs. <br>The scan removes unused preallocation from clean inodes and releases the unused space back to the free pool.<br>(Units: seconds, Default: 300)<br><br><br>- fs.xfs.stats_clear <br><br>Setting this to &quot;1&quot; clears accumulated XFS statistics in /proc/fs/xfs/stat.  It then immediately resets to &quot;0&quot;.<br>(Default: 0)<br><br><br>- fs.xfs.xfsbufd_centisecs <br><br>The interval at which xfsbufd scans the dirty metadata buffers list.<br><br><br>- fs.xfs.xfssyncd_centisecs <br><br>The interval at which the xfssyncd thread flushes metadata out to disk.  <br>This thread will flush log activity out, and do some processing on unlinked inodes.<br>======================<br><br>@ kernel<br><br>- kernel.numa_balancing <br><br>Enables/disables automatic page fault based NUMA memory balancing. Memory is moved automatically to nodes that access it often.<br><br>Enables/disables automatic NUMA memory balancing. On NUMA machines, there is a performance penalty if remote memory is accessed by a CPU. When this feature is enabled the kernel samples what task thread is accessing memory by periodically unmapping pages and later trapping a page fault. At the time of the page fault, it is determined if the data being accessed should be migrated to a local memory node.<br><br>The unmapping of pages and trapping faults incur additional overhead that ideally is offset by improved memory locality but there is no universal guarantee. If the target workload is already bound to NUMA nodes then this feature should be disabled. Otherwise, if the system overhead from the feature is too high then the rate the kernel samples for NUMA hinting faults may be controlled by the numa_balancing_scan_period_min_ms, numa_balancing_scan_delay_ms, numa_balancing_scan_period_max_ms, numa_balancing_scan_size_mb, and numa_balancing_settle_count sysctls.<br><br><br>- kernel.numa_balancing_scan_delay_ms <br>- kernel.numa_balancing_scan_period_max_ms <br>- kernel.numa_balancing_scan_period_min_ms <br>- kernel.numa_balancing_scan_size_mb <br>- kernel.numa_balancing_settle_count <br><br>Automatic NUMA balancing scans tasks address space and unmaps pages to detect if pages are properly placed or if the data should be migrated to a memory node local to where the task is running. Every &quot;scan delay&quot; the task scans the next &quot;scan size&quot; number of pages in its address space. When the end of the address space is reached the scanner restarts from the beginning.<br><br>In combination, the &quot;scan delay&quot; and &quot;scan size&quot; determine the scan rate. When &quot;scan delay&quot; decreases, the scan rate increases.  The scan delay and hence the scan rate of every task is adaptive and depends on historical behaviour. If pages are properly placed then the scan delay increases, otherwise the scan delay decreases.  The &quot;scan size&quot; is not adaptive but<br>the higher the &quot;scan size&quot;, the higher the scan rate.<br><br>Higher scan rates incur higher system overhead as page faults must be trapped and potentially data must be migrated. However, the higher the scan rate, the more quickly a tasks memory is migrated to a local node if the workload pattern changes and minimises performance impact due to remote memory accesses. These sysctls control the thresholds for scan delays and the number of pages scanned.<br><br>numa_balancing_scan_period_min_ms is the minimum time in milliseconds to scan a tasks virtual memory. It effectively controls the maximum scanning rate for each task.<br><br>numa_balancing_scan_delay_ms is the starting &quot;scan delay&quot; used for a task when it initially forks.<br><br>numa_balancing_scan_period_max_ms is the maximum time in milliseconds to scan a tasks virtual memory. It effectively controls the minimum scanning rate for each task.<br><br>numa_balancing_scan_size_mb is how many megabytes worth of pages are scanned for a given scan.<br><br>numa_balancing_settle_count is how many scan periods must complete before the schedule balancer stops pushing the task towards a preferred node. This gives the scheduler a chance to place the task on an alternative node if the preferred node is overloaded.<br>======================<br>@ net<br><br>- net.core.bpf_jit_enable <br><br>This enables Berkeley Packet Filter Just in Time compiler. Currently supported on x86_64 architecture, bpf_jit provides a framework to speed packet filtering, the one used by tcpdump/libpcap for example.<br>Values :<br>        0 - disable the JIT (default value)<br>        1 - enable the JIT<br>        2 - enable the JIT and ask the compiler to emit traces on kernel log.<br><br><br>- net.core.default_qdisc <br><br>The default queuing discipline to use for network devices. This allows overriding the default queue discipline of pfifo_fast with an alternative. Since the default queuing discipline is created with the no additional parameters so is best suited to queuing disciplines that work well without configuration like stochastic fair queue (sfq), CoDel (codel) or fair queue CoDel (fq_codel). Don't use queuing disciplines like Hierarchical Token Bucket or Deficit Round Robin which require setting up classes and bandwidths.<br>Default: pfifo_fast<br><br><br>- net.core.netdev_tstamp_prequeue <br><br>If set to 0, RX packet timestamps can be sampled after RPS processing, when the target CPU processes packets. It might give some delay on timestamps, but permit to distribute the load on several cpus.<br><br>If set to 1 (default), timestamps are sampled as soon as possible, before queueing.<br><br><br>- net.ipv4.tcp_autocorking <br><br>Enable TCP auto corking : When applications do consecutive small write()/sendmsg() system calls, we try to coalesce these small writes as much as possible, to lower total amount of sent packets. This is done if at least one prior packet for the flow is waiting in Qdisc queues or device transmit queue. Applications can still use TCP_CORK for optimal behavior when they know how/when to uncork their sockets.<br>Default : 1<br><br><br>- net.ipv4.tcp_early_retrans <br><br>Enable Early Retransmit (ER), per RFC 5827. ER lowers the threshold for triggering fast retransmit when the amount of outstanding data is small and when no previously unsent data can be transmitted (such that limited transmit could be used). Also controls the use of Tail loss probe (TLP) that converts RTOs occuring due to tail losses into fast recovery (draft-dukkipati-tcpm-tcp-loss-probe-01).<br>        Possible values:<br>                0 disables ER<br>                1 enables ER<br>                2 enables ER but delays fast recovery and fast retransmit<br>                  by a fourth of RTT. This mitigates connection falsely<br>                  recovers when network has a small degree of reordering<br>                  (less than 3 packets).<br>                3 enables delayed ER and TLP.<br>                4 enables TLP only.<br>Default: 3<br><br><br>- net.ipv4.tcp_fastopen <br><br>Enable TCP Fast Open feature (draft-ietf-tcpm-fastopen) to send data in the opening SYN packet. To use this feature, the client application must use sendmsg() or sendto() with MSG_FASTOPEN flag rather than connect() to perform a TCP handshake automatically.<br><br>        The values (bitmap) are<br>        1: Enables sending data in the opening SYN on the client.<br>        2: Enables TCP Fast Open on the server side, i.e., allowing data in<br>           a SYN packet to be accepted and passed to the application before<br>           3-way hand shake finishes.<br>        4: Send data in the opening SYN regardless of cookie availability and<br>           without a cookie option.<br>        0x100: Accept SYN data w/o validating the cookie.<br>        0x200: Accept data-in-SYN w/o any cookie option present.<br>        0x400/0x800: Enable Fast Open on all listeners regardless of the<br>           TCP_FASTOPEN socket option. The two different flags designate two<br>           different ways of setting max_qlen without the TCP_FASTOPEN socket<br>           option.<br><br>Default: 0<br><br>Note that the client &amp; server side Fast Open flags (1 and 2 respectively) must be also enabled before the rest of flags can take effect.<br><br><br>- net.ipv4.tcp_fastopen_key <br><br>To allow manual rekeying for server side Fast Open cookie operations<br><br><br>- net.ipv4.tcp_invalid_ratelimit <br><br>Limit the maximal rate for sending duplicate acknowledgments in response to incoming TCP packets that are for an existing connection but that are invalid due to any of these reasons:<br><br>          (a) out-of-window sequence number,<br>          (b) out-of-window acknowledgment number, or<br>          (c) PAWS (Protection Against Wrapped Sequence numbers) check failure<br><br>This can help mitigate simple &quot;ack loop&quot; DoS attacks, wherein a buggy or malicious middlebox or man-in-the-middle can rewrite TCP header fields in manner that causes each endpoint to think that the other is sending invalid TCP segments, thus causing each side to send an unterminating stream of duplicate acknowledgments for invalid segments.<br><br>Using 0 disables rate-limiting of dupacks in response to invalid segments; otherwise this value specifies the minimal space between sending such dupacks, in milliseconds.<br>Default: 500 (milliseconds).<br><br><br>- net.ipv4.tcp_notsent_lowat<br><br>A TCP socket can control the amount of unsent bytes in its write queue, thanks to TCP_NOTSENT_LOWAT socket option. poll()/select()/epoll() reports POLLOUT events if the amount of unsent bytes is below a per socket value, and if the write queue is not full. sendmsg() will also not add new buffers if the limit is hit.<br><br>This global variable controls the amount of unsent data for sockets not using TCP_NOTSENT_LOWAT. For these sockets, a change to the global variable has immediate effect.<br><br>Default: UINT_MAX (0xFFFFFFFF)<br><br><br>감사합니다.<br><br><publishedDate>2016-05-04T05:12:48Z</publishedDate><createdByType>Associate</createdByType><br>======================<br><comment id="a0aA000000H4JnyIAF"><br>======================<br><b>생성계정 : kim, jimin</b><br><b>생성날짜 : 2016-05-04T01:40:02Z</b><br><b>마지막 답변자 : kim, jimin</b><br><b>마지막 수정 일자 : 2016-05-04T01:40:01Z</b><br><br>7버전에서 추가된 아래 파라미터에 대해 정확한 용도 설명 요청 드립니다.<br><br>vm.user_reserve_kbytes <br>fscache.object_max_active <br>fscache.operation_max_active <br><br>fs.xfs.age_buffer_centisecs <br>fs.xfs.error_level <br>fs.xfs.filestream_centisecs <br>fs.xfs.inherit_noatime <br>fs.xfs.inherit_nodefrag <br>fs.xfs.inherit_nodump <br>fs.xfs.inherit_nosymlinks <br>fs.xfs.inherit_sync <br>fs.xfs.irix_sgid_inherit <br>fs.xfs.irix_symlink_mode <br>fs.xfs.panic_mask <br>fs.xfs.rotorstep <br>fs.xfs.speculative_prealloc_lifetime <br>fs.xfs.stats_clear <br>fs.xfs.xfsbufd_centisecs <br>fs.xfs.xfssyncd_centisecs <br><br>kernel.numa_balancing <br>kernel.numa_balancing_scan_delay_ms <br>kernel.numa_balancing_scan_period_max_ms <br>kernel.numa_balancing_scan_period_min_ms <br>kernel.numa_balancing_scan_size_mb <br>kernel.numa_balancing_settle_count <br><br>net.core.bpf_jit_enable <br>net.core.default_qdisc <br>net.core.netdev_tstamp_prequeue <br>net.ipv4.tcp_autocorking <br>net.ipv4.tcp_early_retrans <br>net.ipv4.tcp_fastopen <br>net.ipv4.tcp_fastopen_key <br>net.ipv4.tcp_invalid_ratelimit <br>net.ipv4.tcp_notsent_lowat<br><br><publishedDate>2016-05-04T01:40:01Z</publishedDate><createdByType>Customer</createdByType><br>======================<br><comment id="a0aA000000Gwqa3IAB"><br>======================<br><b>생성계정 : HAN, JINKOO</b><br><b>생성날짜 : 2016-04-21T05:35:33Z</b><br><b>마지막 답변자 : HAN, JINKOO</b><br><b>마지막 수정 일자 : 2016-04-21T05:35:32Z</b><br><br>안녕하세요,<br>Red Hat 한진구 입니다.<br><br>우선 커널의 파라미터들에 대한 고려는 사실 해당 시스템의 workload 그리고 시스템 사양 및 환경 등등에 의해서 그리고 해당 요소들에 영향을 미치게 됨에따라, 일률적으로 어떤 파라미터를 어떻게 고쳐라라고 하기는 어려운 것이 사실입니다.<br><br>우선적으로 Red Hat은 default 값이 일반적인 권장사항으로 이해하시면 되며, 추가적으로 제 개인적으로 몇가지를 확인해 본다면 아래와 같습니다.<br><br><br>[ *** RHEL7 에 추가 된 파라미터 목록 *** ]<br>fs.xfs.error_level <br>kernel.numa_balancing<br><br><br>운영적인 측면에서 error log level을 높인다던지 numa-balancing이 되는지에 대해서 검토 및 실제 업무별 영향도가 있을지에 대해서는 많은 테스트가 필요해 보입니다.<br>======================<br><br>감사합니다.<br><br><publishedDate>2016-04-21T05:35:32Z</publishedDate><createdByType>Associate</createdByType><br>======================<br><comment id="a0aA000000GwAhPIAV"><br>======================<br><b>생성계정 : HAN, JINKOO</b><br><b>생성날짜 : 2016-04-19T02:20:44Z</b><br><b>마지막 답변자 : HAN, JINKOO</b><br><b>마지막 수정 일자 : 2016-04-19T02:20:44Z</b><br><br>안녕하세요,<br>Red Hat Technical Account Manager 한진구 입니다.<br><br>보내주신 내용에 대해서 우선 검토가 필요할 것 같습니다. 검토 후에 업데이트 드리겠습니다.<br>======================<br><br>감사합니다.<br><br><publishedDate>2016-04-19T02:20:44Z</publishedDate><createdByType>Associate</createdByType><br>======================<br></comments><br><br>보험ERP 프로젝트 진행 중인 SDS 김지민 선임입니다.<br><br>현재 보험ERP 서버들은 RHEL7 버전과 RHEL6 버전으로 구성되어 있습니다.<br><br>6과 7버전에 따라서 동일한 파라미터도 있지만 각각의 버전이 가지고 있는 고유의 파라미터도 있습니다.<br><br>문의드릴점은 아래 첨부로 각 버전 고유의 파라미터를 첨부하였는데요.<br><br>해당 파라미터 중에서 운영에 있어서 확인해볼만한 파라미터가 있는지 확인을 부탁드리려고 합니다.<br><br>좀 광범위한 문의 같기도 합니다.<br><br>ipv6 등은 기본으로 disable 상태이긴해서 고려할 필요는 없을 듯하고<br>또 xfs에 관한 파라미터에 대해서는 xfs를 사용하고있어서 확인하고 있어야할 점이 있는지 해서 <br>일단 문의드립니다.</issue><timeFramesAndUrgency>[ *** RHEL7 에 추가 된 파라미터 목록 *** ]<br>dev.parport.default.spintime <br>dev.parport.default.timeslice <br>fs.binfmt_misc.kshcomp <br>fs.pipe-max-size <br>fs.protected_hardlinks <br>fs.protected_symlinks <br>fs.xfs.age_buffer_centisecs <br>fs.xfs.error_level <br>fs.xfs.filestream_centisecs <br>fs.xfs.inherit_noatime <br>fs.xfs.inherit_nodefrag <br>fs.xfs.inherit_nodump <br>fs.xfs.inherit_nosymlinks <br>fs.xfs.inherit_sync <br>fs.xfs.irix_sgid_inherit <br>fs.xfs.irix_symlink_mode <br>fs.xfs.panic_mask <br>fs.xfs.rotorstep <br>fs.xfs.speculative_prealloc_lifetime <br>fs.xfs.stats_clear <br>fs.xfs.xfsbufd_centisecs <br>fs.xfs.xfssyncd_centisecs <br>fscache.object_max_active <br>fscache.operation_max_active <br>kernel.keys.persistent_keyring_expiry <br>kernel.msg_next_id <br>kernel.ns_last_pid <br>kernel.numa_balancing <br>kernel.numa_balancing_scan_delay_ms <br>kernel.numa_balancing_scan_period_max_ms <br>kernel.numa_balancing_scan_period_min_ms <br>kernel.numa_balancing_scan_size_mb <br>kernel.numa_balancing_settle_count <br>kernel.panic_on_stackoverflow <br>kernel.perf_cpu_time_max_percent <br>kernel.pty.reserve <br>kernel.sem_next_id <br>kernel.shm_next_id <br>kernel.traceoff_on_warning <br>net.core.bpf_jit_enable <br>net.core.default_qdisc <br>net.core.netdev_tstamp_prequeue <br>net.ipv4.igmp_qrv <br>net.ipv4.ip_early_demux <br>net.ipv4.neigh.default.unres_qlen_bytes <br>net.ipv4.neigh.lo.unres_qlen_bytes <br>net.ipv4.tcp_autocorking <br>net.ipv4.tcp_early_retrans <br>net.ipv4.tcp_fastopen <br>net.ipv4.tcp_fastopen_key <br>net.ipv4.tcp_invalid_ratelimit <br>net.ipv4.tcp_notsent_lowat <br>net.ipv6.conf.all.force_tllao <br>net.ipv6.conf.all.mldv1_unsolicited_report_interval <br>net.ipv6.conf.all.mldv2_unsolicited_report_interval <br>net.ipv6.conf.all.ndisc_notify <br>net.ipv6.conf.default.force_tllao <br>net.ipv6.conf.default.mldv1_unsolicited_report_interval <br>net.ipv6.conf.default.mldv2_unsolicited_report_interval <br>net.ipv6.conf.default.ndisc_notify <br>net.ipv6.conf.lo.force_tllao <br>net.ipv6.conf.lo.mldv1_unsolicited_report_interval <br>net.ipv6.conf.lo.mldv2_unsolicited_report_interval <br>net.ipv6.conf.lo.ndisc_notify <br>net.ipv6.mld_qrv <br>net.ipv6.neigh.default.unres_qlen_bytes <br>net.ipv6.neigh.lo.unres_qlen_bytes <br>vm.user_reserve_kbytes <br>net.bridge.bridge-nf-pass-vlan-input-dev<br>======================<br><br>[ *** RHEL6 에는 있지만, RHEL7 에는 없는 파라미터 *** ]<br><br>fs.nfs.idmap_cache_timeout <br>fs.nfs.nfs_callback_tcpport <br>kernel.exec-shield <br>kernel.slow-work.max-threads <br>kernel.slow-work.min-threads <br>kernel.slow-work.vslow-percentage <br>kernel.vsyscall64 <br>net.ipv4.inet_peer_gc_maxtime <br>net.ipv4.inet_peer_gc_mintime <br>net.ipv4.neigh.default.base_reachable_time <br>net.ipv4.neigh.default.retrans_time <br>net.ipv4.neigh.lo.base_reachable_time <br>net.ipv4.neigh.lo.retrans_time <br>net.ipv4.route.secret_interval <br>net.ipv4.rt_cache_rebuild_count <br>net.ipv4.tcp_abc <br>net.ipv4.tcp_dma_copybreak <br>net.ipv4.tcp_frto_response <br>net.sctp.addip_enable <br>net.sctp.addip_noauth_enable <br>net.sctp.addr_scope_policy <br>net.sctp.association_max_retrans <br>net.sctp.auth_enable <br>net.sctp.cookie_hmac_alg <br>net.sctp.cookie_preserve_enable <br>net.sctp.hb_interval <br>net.sctp.max_burst <br>net.sctp.max_init_retransmits <br>net.sctp.path_max_retrans <br>net.sctp.pf_retrans <br>net.sctp.prsctp_enable <br>net.sctp.rcvbuf_policy <br>net.sctp.rto_alpha_exp_divisor <br>net.sctp.rto_beta_exp_divisor <br>net.sctp.rto_initial <br>net.sctp.rto_max <br>net.sctp.rto_min <br>net.sctp.rwnd_update_shift <br>net.sctp.sack_timeout <br>net.sctp.sctp_mem <br>net.sctp.sctp_rmem <br>net.sctp.sctp_wmem <br>net.sctp.sndbuf_policy <br>net.sctp.valid_cookie_life <br>vm.extra_free_kbytes <br>vm.meminfo_legacy_layout <br>vm.scan_unevictable_pages <br>vm.unmap_area_factor <br>vm.would_have_oomkilled</timeFramesAndUrgency><cep>false</cep></case>