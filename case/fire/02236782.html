======================<br><b>생성계정 : support os</b><br><b>생성날짜 : 2018-10-23T06:27:11Z</b><br><b>마지막 답변자 : GSS Tools</b><br><b>마지막 수정 일자 : 2018-11-24T11:03:08Z</b><br><b>id : 500A000000cPuy0IAC</b><br>======================<br><br><b><font size=15>
제목  : 네트워크 장애 발생시  nfs client 옵션에 따라 반응하는 순서를 알고싶습니다.
</font></b><br><br>======================<br><b>사전문의<br></b><br>어떤 문제/오류/결함이 발생했습니까? 기대하시는 결과는 무엇입니까?<br><br>네트워크 작업중  순단이 발생했는데 일부 서버(nfs client) 가 접속이 끊기고 나서 재 접속까지 15분 가량 시간이 소요되었습니다.  nfs client 옵션에 따라서 어떻게 적용되는지 알고싶습니다.<br>=======================<br><b>상태 : Closed</b><br><b>제품명  : Red Hat Enterprise Linux</b><br><b>버젼  : 7.2</b><br><b>타입  : Configuration issue</b><br><b>계정 번호  : 1596892</b><br><b>심각도  : 4 (Low)</b><br><hostname>[삼성화재][ERP]운영계 서버</hostname><br><br><br><comment id="a0aA000000O7vakIAB"><br>======================<br><b>생성계정 : Song, Chang-An</b><br><b>생성날짜 : 2018-11-09T02:07:20Z</b><br><b>마지막 답변자 : Song, Chang-An</b><br><b>마지막 수정 일자 : 2018-11-09T02:07:20Z</b><br><br>안녕하세요? Red Hat 송 창 안 입니다.<br><br>유선상 문의 주신 내용에서 RPC에서의 연결 재시도 부분에 대해서는 확인 한 내용을 업데이트 하도록 하겠습니다.<br><br>이 프로세스의 패킷 캡처를 수행하는 경우 대략 다음 시간대의 타임 라인을 유추 할수 있습니다.<br>  (*** 참고 :이 시간은 네트워크가 통신 할 수 없다고 가정합니다 하며, 이 프로세스의 어떤 시점에서 응답이 오면 시스템이 복구됩니다)<br><br>시스템 변수가 많으며, 이 시간을 정확하게 제공하는 것은 불가능하므로이 값은 근사치로 판단 하시면 됩니다. <br>또한이 설정은 때때로 조정되므로 커널 버전에 따라 약간 다를 수 있습니다. 예를 들어, 일부 커널은 새로운 전송 시도를 시작하기 전에 시간 초과 후 5 초를 지연시킬 수 있습니다.<br><br>      seconds<br>          0.0 - tcp packet is transmitted<br>+  0.2    0.2 - tcp retransmission<br>+  0.4    0.6 - tcp retransmission<br>+  0.8    1.4 - tcp retransmission<br>+  1.6    3.0 - tcp retransmission<br>+  3.2    6.2 - tcp retransmission<br>+  6.4   12.6 - tcp retransmission<br>+ 12.8   25.4 - tcp retransmission<br>+ 25.6   51.0 - rpc minor timeout (first tcp timeout following the 30-second rpc 'timeo')<br>                tcp packet is transmitted<br>+  0.2   51.2 - tcp retransmission<br>+  0.4   51.6 - tcp retransmission<br>+  0.8   52.4 - tcp retransmission<br>+  1.6   54.0 - tcp retransmission<br>+  3.2   57.2 - tcp retransmission<br>+  6.4   63.6 - tcp retransmission<br>+ 12.8   76.4 - tcp retransmission<br>+ 25.6  102.0 - rpc minor timeout (first tcp timeout following the 30-second rpc 'timeo', started at 51.0)<br>                tcp packet is transmitted<br>+  0.2  102.2 - tcp retransmission<br>+  0.4  102.6 - tcp retransmission<br>+  0.8  103.4 - tcp retransmission<br>+  1.6  105.0 - tcp retransmission<br>+  3.2  108.2 - tcp retransmission<br>+  6.4  114.6 - tcp retransmission<br>+ 12.8  127.4 - tcp retransmission<br>+ 25.6  153.0 - rpc major timeout (first tcp timeout following the 30-second rpc 'timeo', started at 102.0)<br><br>좀더 자세히 각 파라메터와 tcp와 RPC 에대해서 timeout에 대한 정의는 아래의 내용과 같습니다.<br><br>XXXXXXX01:/XXX_XXX       /XXX/XXXX        nfs     vers=3,proto=tcp,bg,hard,intr,timeo=300,retrans=2,wsize=65536,rsize=65536,_netdev       0 0<br>언급한 마운트 옵션을 사용하면 'not responding, still trying'메시지는 매 90 초보다 자주 발생합니다. <br><br>'timeo'매개 변수는 1/10 초 단위로 측정되며, 300은 30 초를 나타냅니다. <br>각 rpc 요청이 전송되면 타이머가 'timeo'로 설정되고 rpc 계층은 네트워크 트래픽을 tcp 계층으로 전달하는 과정을 진행 하게 됩니다. <br>tcp 계층은 패킷을 서버로 전송하려고 시도하며 네트워크 전송 과정은 다른 tcp 트래픽과 동일하게 동작하게 됩니다.<br>tcp 전송 실패시, tcp 재전송 타이머는 0.2 초에서 시작하여 매번 두배 설정 됩니다. <br><br>이 tcp 타이머 중 하나가 끝날 때 'timeo'가 초과되면 전송에 대한 제어권이 rpc 계층로 되돌아가며, timeout가 기록됩니다. <br>이후 다음 rpc 계층은 tcp 계층에 대한 또 다른 호출을 시작합니다. tcp 계층은 0.2 초의 tcp 시간 초과로 시작하여 각 시간을 두배로 설정하여 프로세스를 반복합니다.<br>전송에 대한 제어권이 rpc 계층으로 되돌아 왔을 때 'retrans' minor timeout이 이미 발생하면, major timeout이 발생 하므로 <br>'retrans'가 2 인 경우 major timeout이 기록되기 전에 두 개의 minor timeout이 발생 하는 것을 의미합니다. <br>또한, 'hard'마운트 옵션을 사용하면 연결이 다시 설정 될 때까지이 프로세스가 계속됩니다.<br><br>감사합니다.<br>송 창 안 드림.<br><br><publishedDate>2018-11-09T02:07:20Z</publishedDate><createdByType>Associate</createdByType><br>======================<br><comment id="a0aA000000O7cWBIAZ"><br>======================<br><b>생성계정 : Song, Chang-An</b><br><b>생성날짜 : 2018-11-08T00:30:21Z</b><br><b>마지막 답변자 : Song, Chang-An</b><br><b>마지막 수정 일자 : 2018-11-08T00:30:20Z</b><br><br>안녕하세요? Red Hat 송 창 안 입니다.<br><br>현재까지의 진행 사항을 업데이트 하도록 하겠습니다.<br>유선상 문의 주신 내용은 관련 전문 엔지니어에게 문의를 진행 한 상태 입니다.<br><br>관련 내용에 대해서 전문 엔지니어가 확인하여 업데이트 되는 대로 공유 하도록 하겠습니다.<br><br>감사합니다.<br>송 창 안 드림.<br><br><publishedDate>2018-11-08T00:30:20Z</publishedDate><createdByType>Associate</createdByType><br>======================<br><comment id="a0aA000000O6mXKIAZ"><br>======================<br><b>생성계정 : Song, Chang-An</b><br><b>생성날짜 : 2018-11-05T07:06:54Z</b><br><b>마지막 답변자 : Song, Chang-An</b><br><b>마지막 수정 일자 : 2018-11-05T07:06:54Z</b><br><br>안녕하세요? Red Hat 송 창 안 입니다.<br><br>유선상 문의 주신 내용에서 RPC에서의 연결 재시도 부분에 대해서는 확인 후 추가적으로 업데이트 하도록 하겠습니다.<br><br>감사합니다.<br>송 창 안 드림.<br><br><publishedDate>2018-11-05T07:06:54Z</publishedDate><createdByType>Associate</createdByType><br>======================<br><comment id="a0aA000000O6R9tIAF"><br>======================<br><b>생성계정 : Song, Chang-An</b><br><b>생성날짜 : 2018-11-02T06:36:47Z</b><br><b>마지막 답변자 : Song, Chang-An</b><br><b>마지막 수정 일자 : 2018-11-02T06:36:47Z</b><br><br>안녕하세요? Red Hat 송 창 안 입니다.<br><br>문의 주신 내용에 대해서 확인된 내용을 업데이트 하겠습니다.<br><br>NFS client 와 server가 연결 되는 부분을 도식화 한 그림입니다.<br>실제로 사용자는 아래와 같이 여러 단계를 거쳐서 작업을 진행 하게 됩니다.<br><br>+----------------------------------------------+                       +----------------------------------------------+<br>|Client                                        |                       |SERVER                                        |<br>|                                              |                       |                                              |<br>|          +----------------------+            |                       |          +----------------------+            |<br>|          |                      |            |                       |          |                      |            |<br>|          |  System call layer   |            |                       |          |  System call layer   |            |<br>|          |                      |            |                       |          |                      |            |<br>|          +-----------+----------+            |                       |          +----------------------+            |<br>|                      |                       |                       |                                              |<br>|                      |                       |                       |                                              |<br>|          +-----------v----------+            |                       |          +----------------------+            |<br>|          | Virtual file system  |            |                       |          | Virtual file system  |            |<br>|          |   (VFS) layer        |            |                       |          |   (VFS) layer        |            |<br>|          |                      |            |                       |          |                      |            |<br>|          +----+--------------+--+            |                       |          +--^-----------------+-+            |<br>|               |              |               |                       |             |                 |              |<br>|               |              |               |                       |             |                 |              |<br>|  +------------v----+   +-----v-----------+   |                       |  +----------+------+    +-----v-----------+  |<br>|  |   Local file    |   |       NFS       |   |                       |  |       NFS       |    |   Local file    |  |<br>|  | system interface|   |     client      |   |                       |  |      Server     |    | system interface|  |<br>|  +------------+----+   +-----+-----------+   |                       |  +--------^--------+    +------+----------+  |<br>|               |              |               |                       |           |                    |             |<br>|               |              |               |                       |           |                    |             |<br>|  +------------v----+   +-----v------------+  |                       |  +--------+---------+   +------v----------+  |<br>|  |                 |   |  RPC client      |  |                       |  |  RPC  Server     |   |                 |  |<br>|  |      DISK       |   |     stub         |  |      RPC Protocol     |  |     stub         |   |     DISK        |  |<br>|  |                 |   |      +         +-|-----------------------------|-+      ^         |   |                 |  |<br>|  +-----------------+   +------|-----------+  |                       |  +--------|---------+   +-----------------+  |<br>|                               |              |                       |           |                                  |<br>+----------------------+--------|--------------+                       +-----------|-----------+----------------------+<br>                       |        |                                                  |           |<br>                       |        |                                                  |           |<br>                       |     +--v-------------------------+                        |           |<br>                       |     | XDR||    ||    ||    ||    +------------------------+           |<br>                       |     +----------------------------+                                    |<br>               +-------+-----------------------------------------------------------------------+--------------+<br>               Network<br>======================<br>RPC client가 RPC call을하면, 사용 가능한 경우 RPC 요청 슬롯을 할당합니다. 그렇지 않으면, 백 로그 대기열 (xprt_reserve)에서 대기를 하게 됩니다.<br>이후,  호출자는 RPC 메시지를 집어 넣고,  request struct 에 채우고 xprt_transmit()함수를 호출합니다.<br>xprt_transmit은 메시지를 전송하고 호출자를 전송의 대기 목록에 설치하게 됩니다. 동시에 회신이 예상되는 경우 패킷의 제한 시간이 만료 된 후에 실행되는 타이머가 설치됩니다.<br>패킷이 도착하면 data_ready 핸들러는 해당 전송에 대한 보류중인 requests 목록을 탐색합니다. 일치하는 XID가 발견되면 호출자가 깨어나고 타이머가 제거됩니다.<br>만약 시간 초과 간격 내에 응답이 도착하지 않으면 타이머가 커널에 의해 시작되고 xprt_timer()가 실행됩니다. 타임 아웃 값을 조정 (마이너 타임 아웃)하거나 -ETIMEDOUT 상태로 호출자를 깨 웁니다.<br><br>호출자가 RPC에서 응답이 도착했다는 알림을 받으면 RPC 슬롯을 해제하고 응답을 처리해야합니다.<br>호출 시간이 초과되면 초기 시간 초과 값을 조정하여 작업을 재 시도하고 단순히 rpc_call을 다시 호출 할 수 있습니다.<br><br>앞서 제공 해주신 시간 단위로 이벤트가 발생된 것을 유추 했을 때 다음과 같습니다.<br>Oct 21 00:22:08 이슈가 발생 하였으며,  retrans * timeo 시간 전에 발생 된것으로 판단.                       &lt;-------------- 90 sec <br>Oct 21 00:23:22 - nfs: server 42.1.158.33 not responding, still trying seen                       &lt;-------------- 90 sec<br>Oct 21 00:24:54 - nfs: server 42.1.158.33 not responding, still trying seen                       &lt;-------------- 90 sec<br>.... 중간 과정은 RPC 복구 과정에 해당이 되며, <br>Oct 21 00:39:02 - nfs: server 42.1.158.33 OK Problem END: 'OK' seen                               &lt;-------------- 15 min 52 sec <br>                                                                                                                  RPC 연결 완료<br><br>여기의 메시지는 NFS 클라이언트가 NFS 서버에서 실행중인 RPC 작업 (struct rpc_task 데이터 구조로 관리됩니다)되며,  ETIMEDOUT로 제한하고 재 시도를 시도하고 있음을 나타냅니다. <br>또한 struct rpc_task 구조체의 tk_flags에는 RPC_CALL_MAJORSEEN 플래그가 설정되어 있습니다. 즉 이미 major 타임 아웃이 발생하고 있음을 나타냅니다. <br>앞서 말한대로 현재 timeo 파라메터에 대해서 300의 설정 하였으며, 또한 해당 메시지 ( &quot;not responding&quot;) 는 retrans에서 지정 횟수 시도하는 재전송마다 출력합니다.<br>또한,  현재의 설정으로 retrans 파라메터 값이 2이므로 ETIMEDOUT 후 2 회 재전송 시도 후 추가 RPC 연결에 대해서 복구 작업을 수행하는 동작진행 하게 됩니다.<br>추가적으로 RPC 복구에 대한 자세한 과정에 대해서는 rpcdebug -m rpc -s all 명령을 통해서 /var/log/message 에서 확인이 가능 합니다.<br><br>아래 과정은 이해를 돕기 위해서, 커널에 포함된 NFS 와 RPC에 관련된 메세지에 대해서 확인된 부분을 설명하기 위해서 첨부 하였습니다.<br><br>nfs mount할 때 사용된 파라메터 값 중, retran 와 timeo 값이 초기화 되는 부분 입니다.<br>void nfs_init_timeout_values(struct rpc_timeout *to, int proto,<br>                                    unsigned int timeo, unsigned int retrans)<br>{<br>....<br>        to-&gt;to_initval = timeo * HZ / 10;                                            &lt;--------------- 30<br>        to-&gt;to_retries = retrans;                                                    &lt;--------------- 2<br>....<br>        switch (proto) {<br>        case XPRT_TRANSPORT_TCP:<br>        case XPRT_TRANSPORT_RDMA:<br>                if (to-&gt;to_retries == 0)<br>                        to-&gt;to_retries = NFS_DEF_TCP_RETRANS;<br>                if (to-&gt;to_initval == 0)<br>                        to-&gt;to_initval = NFS_DEF_TCP_TIMEO * HZ / 10;<br>                if (to-&gt;to_initval &gt; NFS_MAX_TCP_TIMEOUT)<br>                        to-&gt;to_initval = NFS_MAX_TCP_TIMEOUT;<br>                to-&gt;to_increment = to-&gt;to_initval;                                   &lt;--------------- 30<br>                to-&gt;to_maxval = to-&gt;to_initval + (to-&gt;to_increment * to-&gt;to_retries);&lt;--------------- 30*(2+30) = 90 sec<br>                if (to-&gt;to_maxval &gt; NFS_MAX_TCP_TIMEOUT)<br>                        to-&gt;to_maxval = NFS_MAX_TCP_TIMEOUT;<br>                if (to-&gt;to_maxval &lt; to-&gt;to_initval)<br>                        to-&gt;to_maxval = to-&gt;to_initval;<br>                to-&gt;to_exponential = 0;<br>                break;<br>}<br><br>RPC 복구 과정에 call_timeout 함수이며, rpc stat machine 에 해당하는 과정에서 호출이 됩니다.<br><br>@net/sunrpc/clnt.c <br>static void<br>call_timeout(struct rpc_task *task)<br>{<br>        struct rpc_clnt *clnt = task-&gt;tk_client;<br><br>        if (xprt_adjust_timeout(task-&gt;tk_rqstp) == 0) {<br>                dprintk(&quot;RPC: %5u call_timeout (minor)\n&quot;, task-&gt;tk_pid);<br>                goto retry;                                                                &lt;---------------    debug meesage에서만 확인 가능 , minor time out 일때  <br>        }                                                                                                      call_timeout을 출력합니다.<br><br>        dprintk(&quot;RPC: %5u call_timeout (major)\n&quot;, task-&gt;tk_pid);<br>        task-&gt;tk_timeouts++;<br><br>        if (RPC_IS_SOFTCONN(task)) {<br>                rpc_exit(task, -ETIMEDOUT);<br>                return;<br>        }<br>        if (RPC_IS_SOFT(task)) {<br>                if (clnt-&gt;cl_chatty) {<br>                        rcu_read_lock();<br>                        printk(KERN_NOTICE &quot;%s: server %s not responding, timed out\n&quot;,     &lt;--------------- soft 인 경우, timed out 메시지 출력, 요청 중단하게 됩니다.<br>                                clnt-&gt;cl_program-&gt;name,<br>                                rcu_dereference(clnt-&gt;cl_xprt)-&gt;servername);<br>                        rcu_read_unlock();<br>                }<br>                if (task-&gt;tk_flags &amp; RPC_TASK_TIMEOUT)<br>                        rpc_exit(task, -ETIMEDOUT);<br>                else<br>                        rpc_exit(task, -EIO);<br>                return;<br>        }<br><br>        if (!(task-&gt;tk_flags &amp; RPC_CALL_MAJORSEEN)) {                                     &lt;---------------- RPC_CALL_MAJORSEEN이 아닌 경우, 현재의 루틴을 진입 허용.<br>                task-&gt;tk_flags |= RPC_CALL_MAJORSEEN;                                     &lt;---------------- 진입한 경우, RPC_CALL_MAJORSEEN 플레그를 셋팅.<br>                if (clnt-&gt;cl_chatty) {<br>                        rcu_read_lock();<br>                        printk(KERN_NOTICE &quot;%s: server %s not responding, still trying\n&quot;, &lt;--------------- hard 인 경우, still trying 메시지 출력, 계속 데이터 요청<br>                        clnt-&gt;cl_program-&gt;name,                                                             기본적으로 retrans * timeo 즉, 90 sec 마다 시도 합니다.<br>                        rcu_dereference(clnt-&gt;cl_xprt)-&gt;servername);<br>                        rcu_read_unlock();<br>                }<br>        }<br>        rpc_force_rebind(clnt);                                                            &lt;--------------- 강제로 다시 bind를 시도 합니다.<br>        /*<br>         * Did our request time out due to an RPCSEC_GSS out-of-sequence<br>         * event? RFC2203 requires the server to drop all such requests.<br>         */<br>        rpcauth_invalcred(task);<br><br>retry:<br>        task-&gt;tk_action = call_bind;<br>        task-&gt;tk_status = 0;<br>}<br><br>각 각 미리 정의 된 값에 대한 내용입니다.<br>include/linux/sunrpc/sched.h<br><br>/*<br> * RPC task flags<br> */<br>#define RPC_TASK_ASYNC          0x0001          /* is an async task */<br>#define RPC_TASK_SWAPPER        0x0002          /* is swapping in/out */<br>#define RPC_CALL_MAJORSEEN      0x0020          /* major timeout seen */ &lt;---------------------------<br>#define RPC_TASK_ROOTCREDS      0x0040          /* force root creds */<br>#define RPC_TASK_DYNAMIC        0x0080          /* task was kmalloc'ed */<br>#define RPC_TASK_KILLED         0x0100          /* task was killed */<br>#define RPC_TASK_SOFT           0x0200          /* Use soft timeouts */<br>#define RPC_TASK_SOFTCONN       0x0400          /* Fail if can't connect */<br>#define RPC_TASK_SENT           0x0800          /* message was sent */<br>#define RPC_TASK_TIMEOUT        0x1000          /* fail with ETIMEDOUT on timeout */<br>...<br><br>@net/sunrpc/clnt.c <br>static void<br>call_decode(struct rpc_task *task)<br>{<br>        struct rpc_clnt *clnt = task-&gt;tk_client;<br>        struct rpc_rqst *req = task-&gt;tk_rqstp;<br>        kxdrdproc_t     decode = task-&gt;tk_msg.rpc_proc-&gt;p_decode;<br>        __be32          *p;     <br><br>        dprint_status(task);<br><br>        if (task-&gt;tk_flags &amp; RPC_CALL_MAJORSEEN) {<br>                if (clnt-&gt;cl_chatty) {<br>                        rcu_read_lock();<br>                        printk(KERN_NOTICE &quot;%s: server %s OK\n&quot;,                        &lt;---------------  연결이 완료 되면, 발생되는 메세지         <br>                                clnt-&gt;cl_program-&gt;name,<br>                                rcu_dereference(clnt-&gt;cl_xprt)-&gt;servername);<br>                        rcu_read_unlock();<br>                }<br>                task-&gt;tk_flags &amp;= ~RPC_CALL_MAJORSEEN;                                  &lt;---------------  RPC_CALL_MAJORSEEN 플레그를 삭제 합니다.<br>        }<br>....<br>}<br>======================<br>감사합니다.<br>송 창 안 드림.<br><br><publishedDate>2018-11-02T06:36:47Z</publishedDate><createdByType>Associate</createdByType><br>======================<br><comment id="a0aA000000O5BtmIAF"><br>======================<br><b>생성계정 : Song, Chang-An</b><br><b>생성날짜 : 2018-10-29T02:40:08Z</b><br><b>마지막 답변자 : Song, Chang-An</b><br><b>마지막 수정 일자 : 2018-10-30T02:51:05Z</b><br><br>안녕하세요? Red Hat 송 창 안 입니다.<br>문제 발생시 정보 수집 방법에 대해서 확인 된 내용을 업데이트 하도록 하겠습니다.<br><br>1. NFS Client에서 디버깅 로그 활성화[1]<br><br>NFS 클라이언트에서 nfs 디버깅 로그를 활성화 시킵니다.<br># echo 32767 &gt; /proc/sys/sunrpc/nfs_debug<br><br>rpcdebug 명령어를 통해 같은 동작을 할수 있습니다.<br># rpcdebug -m nfs -s all <br><br>RPC에서 이슈가 있는 경우에 RPC 디버깅 정보를 확인 하기 위해 활성화 시킵니다. <br># echo 32767 &gt; /proc/sys/sunrpc/rpc_debug <br># rpcdebug -m rpc -s all<br><br>활성화 디버깅 로그는 /var/log/message에 로그 되며,  이 후 sosreport 수집으로 정보를 확인 할 수 있습니다.<br>추가적으로 /var/log/아래를 전체 압축 후, 다시 케이스로 업로드 과정도 필요 할것으로 판단 됩니다.<br><br>활성화 시킨 디버깅 로그 레벨은 다시 비활성화 방법 입니다. <br><br># echo 0 &gt; /proc/sys/sunrpc/nfs_debug<br># echo 0 &gt; /proc/sys/sunrpc/rpc_debug <br><br>2. NFS client에서의 tcpdump 수집<br>또한,  /var/log/messages에서 어떤 서버에서 연결 문제가 있는지를  확인 후, tcpdump를 통해 서버 주소에 해당 하는 인터페이스를 찾아서<br>tcpdump를 캡쳐 합니다.[2]<br><br># grep &quot;not responding&quot; /var/log/messages<br>Sep 29 22:54:39 client kernel: nfs: server server.example.com  not responding, still trying<br># tcpdump -i eth0 -s 0 -w /tmp/tcpdump.pcap host server.example.com<br><br>한가지 더 좋은 방법은 아래의 KCS에 첨부된 tcpdump-watch.sh 스크립트를 활용 하면, 손쉽게 필요한 정보에 대해서 수집이 가능합니다.[3]<br>파일은 현재의 케이스에 첨부 하도록 하겠습니다.<br><br># chmod +x tcpdump-watch.sh<br># ./tcpdump-watch.sh 케이스번호 nfs-server-ip주소1 [nfs-server-ip주소2 ... nfs-server-ip주소N개]<br><br>[4]에 첨부한 저희 KCS 문서에서도 client 측면에서 간단하게 정보를 수집하는 방법에 대해서 설명 해두었으며, <br><br>[1]How can the NFS and RPC logging levels be increased in Red Hat Enterprise Linux? <br>https://access.redhat.com/solutions/436853<br>[2]RHEL mount hangs: nfs: server [...] not responding, still trying <br>https://access.redhat.com/solutions/28211<br>[3]I'm encountering an issue with NFS in my environment, what information do I need to capture and provide to Red Hat Support to troubleshoot my issue? <br>https://access.redhat.com/solutions/544883<br>[4]Is there a simple way to gather a packet capture on an NFS client mount point? <br>https://access.redhat.com/articles/1163893<br><br>- NFS client에서 네트워크가 끊기고 나서 어떻게 재 시도를 하고  네트워크가 정상이 될때까지 어떤 동작에 대해서는 확인 후 추가적으로 업데이트 하도록 하겠습니다.<br><br>추가적으로 문의 사항이 있으시면, 업데이트 부탁드립니다.<br><br>감사합니다.<br>송 창 안 드림.<br><br><publishedDate>2018-10-29T02:40:07Z</publishedDate><createdByType>Associate</createdByType><br>======================<br><comment id="a0aA000000O4Uw0IAF"><br>======================<br><b>생성계정 : Song, Chang-An</b><br><b>생성날짜 : 2018-10-25T04:32:51Z</b><br><b>마지막 답변자 : Song, Chang-An</b><br><b>마지막 수정 일자 : 2018-10-25T04:32:51Z</b><br><br>안녕하세요? Red Hat 송 창 안 입니다.<br><br>유선상으로 확인 한 내용에서 두가지에 대해서 정리 하여 업데이트 하도록 하겠습니다.<br><br>- 문제 발생시 정보 수집 방법<br>- NFS client에서 네트워크가 끊기고 나서 어떻게 재 시도를 하고  네트워크가 정상이 될때까지 어떤 동작<br><br>감사합니다.<br>송 창 안 드림.<br><br><publishedDate>2018-10-25T04:32:51Z</publishedDate><createdByType>Associate</createdByType><br>======================<br><comment id="a0aA000000O4EGQIA3"><br>======================<br><b>생성계정 : os, support</b><br><b>생성날짜 : 2018-10-24T06:39:35Z</b><br><b>마지막 답변자 : os, support</b><br><b>마지막 수정 일자 : 2018-10-24T06:39:35Z</b><br><br>유선 지원 감사드립니다.<br>현재 문제 발생 시 문제가 발생했던 서버와 같은 네트워크 상에 있으면서 문제가 발생하지 않았던 서버의 sosreport 를 준비중입니다.<br>준비되는데로 올리도록 하겠습니다.<br><br>추가적인 질문을 드립니다.<br><br>nfsclient 에서 네트워크 가 문제 발생 후 다시 원복 되었을때 동작하는 방식을 알고 싶습니다.<br><br>네트워크가 끊기고 나서 어떻게 재 시도를 하고  네트워크가 정상이 될때까지 어떤 동작을 하는지 궁금합니다.<br>현재 설정한 값들이 이러한 과정에서 어떠한 영향을 미치는 알고싶습니다.<br><br>원론적인 부분이라 시간이 소요될거라 생각됩니다.  현재 원복 시간에 대한 이슈가 있어서 확인이 필요합니다.<br><br>감사합니다.<br><br><publishedDate>2018-10-24T06:39:35Z</publishedDate><createdByType>Customer</createdByType><br>======================<br><comment id="a0aA000000O3xS2IAJ"><br>======================<br><b>생성계정 : Song, Chang-An</b><br><b>생성날짜 : 2018-10-23T08:59:52Z</b><br><b>마지막 답변자 : Song, Chang-An</b><br><b>마지막 수정 일자 : 2018-10-23T08:59:51Z</b><br><br>안녕하세요? Red Hat 송 창 안 입니다. <br><br>문의 주신 내용에 대해서 유선상으로 확인된 내용을 공유 하도록 하겠습니다.<br>제 생각으로는 아래와 같이 시작이 되었을 것으로 판단이 됩니다.<br><br>Oct 21 00:23:22 Problem BEGIN:  adjusted start time of the problem based on 'timeo' and 'retrans' &lt;--------------<br>Oct 21 00:23:22 - nfs: server 42.1.158.33 not responding, still trying seen                       &lt;--------------<br>Oct 21 00:24:54 - nfs: server 42.1.158.33 not responding, still trying seen                       &lt;--------------<br>Oct 21 00:39:02 - nfs: server 42.1.158.33 OK Problem END: 'OK' seen                               &lt;--------------<br><br>현재의 설명은 아래의 KCS 참조 하여 설명 드린 내용입니다. <br><br>....<br>NOTE: A very low value for timeo NFS mount option, which is much less than the default of 600, may increase the likelihood and frequency of this message. For example, setting timeo=5 with the default retrans=2 will cause this message to be printed if the NFS server takes longer than 0.5 + 1.0 = 1.5 seconds to respond to any NFS request. Under a heavy NFS workload, it is not unusual for an NFS server to take longer than 1.5 seconds to respond to one or more NFS requests. For more information on timeo and retrans, see the NFS manual page (man nfs).<br>....<br><br>RHEL mount hangs: nfs: server [...] not responding, still trying <br>https://access.redhat.com/solutions/28211<br><br>여기에 중요한 옵션은 timeo 와 retrans 에 해당이 되며, 각 옵션 값은 아래와 같이 정의가 됩니다.(man nfs 내용을 확인한 내용이며, 한글로 의역이 있을 수 있습니다.)<br><br>timeo=n        10 분의 1 초 단위로 NFS 클라이언트는 NFS 요청을 재 시도하기 전에 응답을 기다립니다.<br>               TCP를 통한 NFS의 경우 기본 timeo 값은 600 (60 초)입니다. NFS 클라이언트는 선형 백 오프를 수행합니다. 각 재 전송 후 시간 초과는 최대 600 초까지 증가합니다.<br>               각 재 전송 후 NFS 클라이언트는 해당 요청에 대한 시간 초과를 최대 시간 초과 길이 인 60 초까지 두 배로 늘립니다.<br>               <br>retrans=n      NFS 클라이언트가 추가 복구 작업을 시도하기 전에 요청을 재 시도하는 횟수입니다.<br>               NFS 클라이언트는 retrans 재시도 후 &quot;server X.X.X.X not responding&quot;라는 메시지를 출력한 다음 추가 복구를 시도합니다 (하드 마운트 옵션의 유효 여부에 따라 다름).<br><br><br>감사합니다.<br><br>송 창 안 드림.<br><br><publishedDate>2018-10-23T08:59:51Z</publishedDate><createdByType>Associate</createdByType><br>======================<br><comment id="a0aA000000O3vRxIAJ"><br>======================<br><b>생성계정 : os, support</b><br><b>생성날짜 : 2018-10-23T06:29:05Z</b><br><b>마지막 답변자 : os, support</b><br><b>마지막 수정 일자 : 2018-10-23T06:29:05Z</b><br><br>아래는 고객쪽에서 확인 된 장애 내역입니다.<br><br>□ 구성<br><br>  - ERP AP대역(42.1.231.xxx)에서 대외계배치용으로 레거시 NAS(42.1.158.33)에 mount하여 사용중<br><br>□ 현상<br><br>  - L3/L7 PM시 G/W가 fail-over되면서 일부서버에서 대외계배치용NAS filesystem이 약 15분가량 retry후 복구됨 (retry동안은 대외계배치 NAS filesystem만 접근 불가, 그외 파일시스템은 정상)<br><br><br>□ OS 설정 및 로그<br><br>  - 설정<br><br>    42.1.158.33:/b2bd       /NAS/b2b/batch    nfs     vers=3,bg,hard,intr,timeo=300,retrans=2,wsize=65536,rsize=65536,_netdev  0 0<br><br>      → 옵션설명필요<br><br>해당 옵션에 대한 설명 부탁 드립니다.<br><br>  - 로그<br><br>    [root@pmsalp06:~]#cat /var/log/messages | grep -i nfs<br>    Oct 21 00:23:22 pmsalp06 kernel: nfs: server 42.1.158.33 not responding, still trying<br>    Oct 21 00:24:54 pmsalp06 kernel: nfs: server 42.1.158.33 not responding, still trying<br>    Oct 21 00:39:02 pmsalp06 kernel: nfs: server 42.1.158.33 OK<br><br>      → 로그설명필요<br>해당로그가 발생하는 시점에 대한 설명 부탁 드립니다.<br><br><br>□ 대외계배치NAS<br><br>Filesystem                       Size  Used Avail Use% Mounted on<br><br>42.1.158.33:/b2bd                500G  213G  288G  43% /NAS/b2b/batch<br>======================<br>□ 대상서버<br><br>  - pmsalp01 ~ 08, 11 ~ 18<br><br>  - eccalp01 ~ 08, 11 ~ 18<br><br>  - eccalp21 ~ 24<br><br>  - mdgalp01 ~ 04<br>======================<br>□ 영향받은 대상<br><br>  - pmsalp06, eccalp04, eccalp16, eccalp17<br><br><publishedDate>2018-10-23T06:29:05Z</publishedDate><createdByType>Customer</createdByType><br>======================<br></comments><br>